#include "../commheader.h"

/**
 * Notes for chapter 13
 * 默认构造函数 ClassName()
 * 拷贝构造函数 ClassName(const ClassName& c)
 *  - 拷贝构造函数的第一个参数必须是引用类型。
 *  - 拷贝构造函数在几种情况下都会被隐式地使用，因此拷贝构造函数通常不应是explicit的。
 *      - 对类类型的成员，会使用其拷贝构造函数来拷贝；
 *      - 内置类型则直接拷贝；
 * 拷贝初始化的发生：
 *  1. 使用赋值运算符 '=' 的时候；
 *  2. 将一个对象作为实参传递给一个非引用类型的形参；
 *  3. 从一个返回类型为非引用类型的函数返回一个对象；
 *  4. 用花括号列表初始化一个数组中的元素或一个聚合类中的成员；
 *  5. 某些类类型会对它们所分配的对象使用拷贝初始化：
 *      - 当我们初始化标准容器或调用其insert或push成员时（用emplace成员创建的元素都会直接初始化）
 */

class numbered {
    static unsigned value;
public:
    unsigned mysn;
    numbered(): mysn(++value) { }
    // defined for Exercise 13.15
    numbered(const numbered& n): mysn(++value) { }
};

unsigned numbered::value = 0;

void f(numbered n) {
    cout << n.mysn << endl;
}

void g(const numbered& n) {
    cout << n.mysn << endl;
}

// Exercise 13.18
class Employee {
public:
    Employee();
    Employee(const string &name);
    Employee(const Employee &e) = delete;
    Employee& operator=(const Employee &e) = delete;
    unsigned id() {
        return _id;
    }
private:
    static unsigned hide_inc;
    unsigned _id;
    string name;
};

unsigned Employee::hide_inc = 0;
Employee::Employee(): _id(++hide_inc), name("") { }
Employee::Employee(const string &name): _id(++hide_inc), name(name) { }

int main() {
    numbered a, b = a, c = b;
    /**
     * ## Exercise 13.14 
     * three identical numbers.
     * because the operator = uses the copy-initialization
     * which will copy all the non-static members of the class
     * so the three object below have the same *mysn*s
     * 
     * ## Exercise 13.15
     * three different numbers.
     * the copy constructor has changed the member *mysn* of
     * every object generated by the copy-initialization.
     * thus, b has the different *mysn* from a. so does c.
     * while invoking f(), the copy-initialization is also executed
     * to copy a, b and c to the formal parameters 'cause they are not reference.
     * in this case, the output is 4, 5 and 6
     * while a, b and c's *mysn*s are 1, 2 and 3.
     */
    f(a);f(b);f(c);
    /**
     * ## Exercise 13.16
     * three different numbers but the same as a, b and c's *mysn*s.
     * 'cause the formal parameters are const references
     * so the object will not be copied
     * and the copy-initialization will not be executed.
     */
    g(a);g(b);g(c);

    // Exercise 13.18
    Employee e1, e2("John");
    cout << e1.id() << " " << e2.id() << endl;  // 1 2
    // Employee e3(e1);    // error: use of deleted function 'Employee::Employee(const Employee&)'
    // Employee e4 = e1;   // error: use of deleted function 'Employee::Employee(const Employee&)'
}